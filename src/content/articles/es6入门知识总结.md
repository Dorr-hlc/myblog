---
title: es6入门知识点总结
date: 2021-06-30
tags:
  - es6
  - JavaScript
---
本篇博客主要是对es6基础知识点的学习总结

<!-- more -->

# let和const命令

## let基础用法

ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。

```
{
let a = hlc;
var b = 1;
}
a // ReferenceError: a is not defined.
b // 1

```

上面的代码证明let声明的变量只能在它所在的代码块区域有效，在此之外时不能访问到，而var声明的变量可以。

适用let的场景比如for循环:

```
for (let i = 0; i < arr.length; i++) {}
console.log(i);
//ReferenceError: i is not defined
```

下面的代码如果使用var，最后输出的是10。

```
var a = [];
for (var i = 0; i < 10; i++) {
a[i] = function () {
console.log(i);
};
}
a[6](); // 10

```

上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。
如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。

```
var a = [];
for (let i = 0; i < 10; i++) {
a[i] = function () {
console.log(i);
};
}
a[6](); // 6

```

### 注意点

1. **不存在变量提升**：let不像var 那样存在变量提升的现象，所以一定要在声明之后使用，否则会报错
2. **暂时性死区**: 只要块级作用域存在let声明的变量，那么它所声明的变量就会“绑定”当前的区域，不在受外部的影响。比如我提前声明一个全局变量a,然后是我在函数内部再用let去声明一个a,并且在let声明之前去调用他，就会报错。这就被称为“暂时性死区”。
3. **不能重复声明**：let不允许在同一作用域同时声明两个相同的变量。

## 块级作用域

es5只有全局作用域和函数作用域，没有块级作用域，这就会导致内层变量可能会覆盖外层变量，也有可能导致用来计数的循环变量泄露为全局变量。

## const命令

**注意**：const命令是用来声明常量，一旦声明其值就不可再改变，const一旦声明变量，就必须立即初始化，不能留到以后赋值。如果只声明不赋值，也会报错。其作用域也与let 相同，只是在当前声明的块级作用域生效，并且也存在暂时性死区，同样的也只能在声明的位置后面使用。

# 变量的解构赋值

## 数组的解构赋值

#### 基本用法

es6允许从数组和对象中按照一定模式提取值，从而对变量进行赋值，这就被称为解构。

之前只能为变量直接指定值，比如

```
var a = 1;
var b = 2;
var c = 3;
```

es6可以直接写成

```
var [a,b,c] = [1,2,3]
```

其意思就是从数组中提取值，然后赋值给对应的位置的变量。

**注意：**

1. 可以不完全解构
2. 如果解构不成功，那么对应的值就是undefined
3. 如果等号右边的值不是可以遍历的结构，那么也会报错

解构赋值不仅适用于var命令，同样也适用于let,const ；

对于Set结构，也是同样适用

```
var [x,y,c]=new Set(["a","b","c"])
```

### 默认值

解构赋值允许使用默认值

比如

```
let [x,y="2"]=["a"] // x=a,y=2
```

注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。

```
var [x = 1] = [undefined];
x // 1
var [x = 1] = [null];
x // null

```

上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。

## 对象解构赋值

解构不仅可以用于数组，也可以用于对象，对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

```
var { bar, foo } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
var { baz } = { foo: "aaa", bar: "bbb" };
baz // undefined

```
